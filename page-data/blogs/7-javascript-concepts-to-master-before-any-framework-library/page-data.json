{"componentChunkName":"component---src-templates-blog-template-js","path":"/blogs/7-javascript-concepts-to-master-before-any-framework-library","result":{"data":{"blog":{"content":"# 7 Javascript Concepts to Master Before Any Framework / Library\n\n## A simple guide to essential modern JavaScript\n\n![](https://cdn-images-1.medium.com/max/1200/0*ZXZTsLweRfsiNdbG)\nPhoto by [Eric &\nNiklas](https://unsplash.com/@penguinphotography?utm_source=medium&utm_medium=referral)\non [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)\n\nJavaScript libraries/frameworks like React or Vue are ruling the web development\nworld. But to truly appreciate their power, you must have a good understanding\nand command of certain modern JavaScript concepts.\n\nIf you know JavaScript but haven't yet worked with ES6 or any other modern\nversion of JavaScript, then jumping right into something like React might seem\nterrifying. You might not even recognize it as JavaScript and wonder which new\nalien language it is.\n\nRelax! You can pick-up these in no time. This article will serve as your simple\nreference. Don't forget to bookmark it. Also, don't forget to check out the\n**resources** section at the end of this article for further reading.\n\nBuckle up… going we’re lightspeed…\n\n\n### 1. Understand “let” and “const”\n\nI am sure you might be familiar with `var`¹, the quintessential keyword to\ncreate variables in JavaScript. We know that in the course of a program some\nvariables really do not change. They are so-called* constants*. Technically\nthough they are all just variables because JavaScript only knows `var`.\n\nWith ES6, a newer version of JavaScript, two different keywords were introduced\n`let`² and `const`³.\n\nSure `var` still works but you are highly encouraged to use `let` and `const`.\n`Let` is like the new `var`, you use it for variable values.\n\n> The most important takeaway here is to use `let` if you want to create a\n> variable that really is a variable or changes its value. Use `const` if you are\n> creating a constant value, like something that you assign once and never change.\n> This is the case more often than you think when you are using modern JS\n> frameworks / libraries.\n\nLet's have a quick look at how they work. During the older `var` days we would\ndo something like this\n\n    var userName = 'John';\n    console.log(userName);\n\nThen if we re-assign a new value to `username`\n\n    userName = 'Doe';\n    console.log(userName);\n\nLet's Run it. You will see `John` printed first followed by `Doe`\n\nNow instead of `var` we use `let`\n\n    let userName = 'John';\n    console.log(userName);\n\n    userName = 'Doe';\n    console.log(userName);\n\nWhen you rerun the code, you will see the same output, and nothing changes. So\n`let` works essentially as `var`. So, what's the big deal?\n\n> `var` declarations are globally scoped or function/locally scoped. Whereas `let`\n> is block-scoped i.e anything within the curly braces `{}.` Also, `var` variables\n> can be re-declared and updated. `let` variables can only be updated but not\n> re-declared. [Here’s a good article from\n> freecodecamp](https://www.freecodecamp.org/news/var-let-and-const-whats-the-difference/)\n> diving deeper into this difference.\n\nLet's look at `const` now\n\n    const userName = 'John';\n    console.log(userName);\n\n    userName = 'Doe';\n    console.log(userName);\n\nNow if you try to run it, You will see `John` printed first, followed by an\nerror message.\n\n    TypeError: Assignment to constant variable.\n\nThis is because the value of a `const` can’t be changed through reassignment,\nand it can’t be redeclared.\n\n### 2. Arrow Functions and how to use them\n\nOh boy. This one gets me most excited. Another construct that you’ll come across\nthe most is the _arrow functions⁴_. It’s not just syntactic sugar for declaring\nfunctions but also how `this` keyword behaves with arrow functions.\n\nA normal JavaScript function looks like this with the `function` keyword.\n\n    function doSomething() {\n      // some more logic...\n    }\n\nOr you’d have used it as a function expression as\n\n    var doSomething = function() {\n      // Some more logic ...\n    }\n\nnow, this is how an **Arrow function** looks like. Also, known as **Fat arrow\nfunctions.**\n\n    const doSomething = () => {\n     // Some more logic...\n    }\n\nHere we’re storing the function reference into a constant and on the right-hand\nside of `=` is the arrow function’s syntax. A list of arguments go into the\nparenthesis `()`. Here it's none, followed by the `=>` or the arrow, which is\nfollowed by the function body between the curly parenthesis `{}`.\n\n> Arrow function not only has a shorter syntax due to omission of the `function`\n> keyword, it also provides benefits and clears a lot of confusions we used to\n> have with the dreaded `this` keyword.\n\n> Understanding how the notorious `this` keyword works is a nice rabbit hole to\n> fall into. Take a read of these medium articles\n> [here](https://medium.com/search?q=thiskeyword)⁵ .\n\nLet us see a few examples and variations of arrow functions. First, let's start\nwith a normal function as a reference point\n\n    function printUserName(userName) {\n       console.log(userName);\n    }\n\n    printUserName('John');\n\nThe output is *John. *The arrow function equivalent will look like this (Of\ncourse you will use `let` instead of `const` if you plan to reassign the\nfunction )\n\n    const printUserName = (userName)\n     {\n       console.log(userName);\n    }\n\n    printUserName('John');\n\nYou will still see *John *As the output. Let’s look at a few alternatives to\nthis syntax. If you only receive one (exactly one!) argument, you can use the\nshort cut of omitting the parenthesis, like so\n\n    const printUserName = userName\n     {\n       console.log(userName);\n    }\n\n    printUserName('John');\n\nHowever, if you have a function that receives no arguments whatsoever, then you\nwill have to use the empty parenthesis like so\n\n    const printUserName = ()\n     {\n       console.log('John');\n    }\n\n    printUserName();\n\nLikewise, for more than one arguments, you have to use the parenthesis\n\n    const printUserName = (userName, age)\n     {\n       console.log(userName, age);\n    }\n\n    printUserName('John', 28);\n\nThese are the different variations regarding arguments. There is also a\ndifferent alternative regarding the function body. If you have a function that\njust returns something like, say a square of a number. We can have a short form\narrow function like this where you omit the curly braces and also the `return`\nkeyword.\n\n    const squared = number => number ** 2;\n    console.log(squared(3));\n\n### 3. Learn Exports⁶ and Imports⁷ for Modular code\n\nLearning how to write modular JavaScript is essential, even if you are not using\nany Frameworks / Library. The code is split over multiple files for better\nmaintainability and reuse.\n\nThe idea behind `export` and `import` statements or so-called _modules_ is that\ninside of a JavaScript file we can import content from another file. So that the\nJavaScript files themselves know their dependencies.\n\nIt might look like this\n\n![](https://cdn-images-1.medium.com/max/800/1*P1KnfEVKUlf5SZJF9jFL0g.png)\nImage created by author\n\nFirst file `person.js` we have a `constant` _person_ which stores a JavaScript\nobject. we have a default export of this file using the `export` and `default`\nkeywords.\n\nWe also have another file `utility.js` where we export multiple things, a\n`constant` named `clean` which holds a function and `baseData` which holds a\nnumber.\n\nWe have a third file `app.js`. We are importing from `person.js` and\n`utility.js`. which requires a couple of `import` statements.\n\nWe see `person.js` uses the `default` keyword. It merely means that if we import\nsomething from that file it will be the default export. In our case, it will be\nthe `person` constant. Hence we can name `person` whatever we want in app.js,\nyou can see that in the first two statements in app.js we are importing\nperson.js but with two different names `person` and `prs`, the name doesn't\nmatter.\n\n`utility.js` is a bit different, we are importing from two different constants\nand therefore we use the curly braces `{}` to explicitly target specific things\nfrom that file. These are called **named exports**. It is important to provide the\nexact names as in `utility.js`. You can also write this as one statement\n\n    import {clean, baseData} from './utility.js'\n\nWith **default export** you have the liberty to name it as you will\n\n    import person from './person.js'\n    import prs from './person.js'\n\nWith **named export** you can do this\n\n    import {clean} from './utility.js'\n\n    //also use an alias\n    import {clean as cln} from './utility.js'\n\n    //or import everything with * with an alias and use it as bundled.clean\n    import * as bundled from './utility.js'\n\n### 3. Understand Classes⁸\n\nClasses are from the object-oriented programming world and yes you can use them\nin JavaScript too.\n\nThink of classes as blueprints/templates for creating objects. They are like the\ncookie cutter to make cookies, where cookies are the objects. Another example is\nusing stencils to draw shapes, where the stencil is the class and the shapes are\nobjects.\n\nYou define a class using the `class` keyword. A class can have both properties\nand methods. A property is a variable attached to the class. Methods are\nfunctions attached to classes. In the following code-snippet `person` is a\n`class` with `name` as property and `call` is a method\n\n    class Person {\n       name = 'John'\n       call = () => {// Some logic...}\n    }\n\nWhen you want to create an `object` using a `class`, its called _instantiating_\na class. You use the `new`⁹ keyword to instantiate a class ( in other words\ncreate an object).\n\n    const myPerson = new Person()\n    myPerson.call()\n    console.log(myPerson.name)\n\nclasses also support inheritance. You can potentially inherit all the properties\nand methods from another class and adding new ones to your inherited class. You\nuse the `extends` keyword to inherit from classes.\n\n    class person extends Human\n\nLet's look at a quick example of `class`\n\n    class Person {\n      constructor() {\n        this.name = 'John';\n        }\n       printMyName() {\n         console.log(this.name);\n    }\n\n    const person = new Person();\n    person.printMyName();\n\nThe output is _John_\n\nIn the example above, we have defined a `class` `Person`. You will notice that\nwe have used a `constructor` function. Constructor functions allow you to set\nthe default characteristics to the object that is created.\n\nAlso, you will notice that we have used the `this` keyword to refer to the\ncurrent instance of the class.\n\nLet's look at a quick example of inheritance¹⁰ using the same class\n\n    class Human {\n      constructor () {\n        this.gender = 'male';\n        }\n        printGender() {\n          console.log(this.gender);\n        }\n    }\n\n    // Inherit from Human Class\n    class Person\n     Human {\n      constructor() {\n\n    ;\n        this.name = 'John';\n        }\n       printMyName() {\n         console.log(this.name);\n    }\n\n    const person = new Person();\n    person.printMyName();\n    person.printGender();\n\nHere Person class inherits/extends the Human class. You will notice that even\nthe Human class has the constructor function. To access the constructor in the\nHuman class, we have to use the `super()` function.\n\nYou’ll encounter classes more often especially in React for class-based\ncomponents.\n\n\n\n### 4. Use NextGen Properties and Methods in Classes\n\nThe NextGen JavaScript also offers a new syntax for initializing properties and\nmethods.\n\nWe already learnt that properties are like variables attached to\nclasses/objects. Methods are like functions attached to properties/objects.\n\nUsing ES6 format we have seen constructors used as such in classes\n\n    constructor () {\n      this.myProperty = 'value'\n    }\n\nWith NextGen JavaScript, we can assign property directly in the class, skipping\nthe constructor function. Behind the scenes, this will still be transformed into\na constructor function, but you’ll have an easier time writing this.\n\n    myProperty = 'value'\n\nIt’s pretty similar to methods. In ES6 we would have the methods as\n\n    myMethod () {...}\n\nThe NextGen JavaScript way is to use syntax similar to setting a property.\nSimply think of a method as a property that stores a function as a value and\nthen we end up with\n\n    mymethod = () => {...}\n\nOne good advantage of this is since we use the arrow function as a property\nvalue we’ve got no problems with the confusing `this` keyword.\n\nTo see this in action, we can modify the example from the previous section as\nsuch\n\n    class Human {\n      gender = 'male';\n      printGender = () => {\n          console.log(this.gender);\n        }\n    }\n\n    // Inherit from Human Class\n    class Person\n     Human {\n      this.name = 'John';\n       printMyName = () => {\n         console.log(this.name);\n    }\n\n    const person = new Person();\n    person.printMyName();\n    person.printGender();\n\n### 5. The helpful Spread¹¹ & Rest¹² Operators\n\nLet's now look at two new operators that will make our life easier as\ndevelopers. They are the spread and the rest operator. Interestingly they look\nthe same `…` (3 dots). Depending on where you use them, they behave either as\nspread or rest operators.\n\nThe spread operator is used to split up array elements or object properties. So\nwe “spread up” an array or object.\n\nFor example, if we have an old array and we want to add all the elements from\nthe old array to a new array and additionally add a couple of elements this is\nthe syntax we’d use.\n\n    const newArray = [...oldArray, 1,2]\n\nthe `…` in front of `oldArray` will simply pull out all the elements and add\nthem to the new array. The same applies to an object\n\n    const newObject = {...oldObject, newProp: 3}\n\nHere the `…` pulls out the `oldObject` and the values to add them as key-value\npairs of the `newObject`. As a side note if the old object already had a\n`newProp,` it will be overwritten by newProp with value 3 here.\n\nNow let's look at the Rest operator. It’s the same `…` operator but used\ndifferently, here it is used to merge a list of function arguments into an\narray. Here’s an example\n\n    const sortArgs  = (...args) => {\n      return args.sort()\n    }\n\n`sortArgs` function receives an unlimited amount of arguments, with `…`, we only\nwrite one argument `args`. But we may receive more than one argument and they\nwill all be merged into an array. We can apply array methods to our argument\nconveniently.\n\n### 6. Destructuring¹³\n\nDestructuring allows us to easily extract array elements or object properties\nand store them in variables.\n\nI know you are thinking, it sounds like the exact thing the spread operator\ndoes. Hear me out!\n\n> Spread takes out all elements or all properties and distributes them in a new\n> array or object. Destructuring allows us to pull out single elements or\n> properties and store them in variables.\n\nFor Arrays, it looks like this\n\n    [a,b] = ['Hello','John']\n    console.log(a) // prints Hello\n    console.log(b) // prints John\n\nIf we have an array with two elements — Hello and John, then we can use the\nstrange-looking syntax on the left-hand side of the equal sign to assign the\nvariables `a` and `b` to `Hello` and `John` respectively\n\nFor object destructuring, it’s the same syntax but with the curly braces `{}`.\n\n    {name} = {name:'John', age:28}\n    console.log(name) // Prints John\n    console.log(age) // undefined\n\nIn array destructuring the order defines which property we take, for object\ndestructuring its the property name. so `{name}` on the left-hand side of the\n`=` sign targets the `name` property on the right side and pulls out the value.\nThis is why logging `age` property would yield `undefined`.\n\n### 7. Refreshing Primitive¹⁴ and Reference¹⁵ Types\n\nThis isn’t a modern JavaScript concept, but it is super important that you\nunderstand this right. It can save you from unintentionally sacrificing many\nnights debugging!\n\nIf we create a number like this, this is a primitive type\n\n    const number = 5\n\nNow if we create a second number `num2` and assign it to `number`, This actually\ncreates a real new copy of `number` and assigns the value to `num2`.\n\n    const num2 = number\n    console.log(num2) // prints 5\n\n> numbers, strings booleans are primitive types. When ever you reassign or store\n> in another variable a real copy is created.\n\nIf we look at objects and arrays\n\n    const person = {\n      name = 'John'\n    }\n\nNow if we create a second object `secondPerson` and assign `person` as a value\n\n    const secondPerson = person;\n    console.log(secondPerson); // prints same vale as person\n\nWhen we log the value of `secondPerson`, it prints the same value as `person`.\nIt will not have copied the `person` instead, `person` the object is stored in\nmemory and the pointer to this memory location is copied to `secondPerson`.\n\nNow if we change `person` name property after assigning it to `secondPerson`,\nstill, we will see the new value of `person` logged for `secondPerson`.\n\n    const secondPerson = person;\n    person.name = 'Doe'\n    console.log(secondPerson); // prints same value as updated person\n\nThis is the same behavior with arrays. This becomes very important as it can\nlead to unexpected behavior in code. If you copy arrays or objects like this\nwith an intention to create actual copies this won't work!\n\nTo create actual copies for reference types we can use the spread operator `…`.\nSo our modified code will look like this\n\n    const person = {\n      name = 'John'\n    };\n\n    const secondPerson = {\n      ...person\n    };\n\nNow `seconPerson` is an actual copy. Modifying `person` will not affect\n`secondPerson`.\n\n### Conclusion\n\nIf you made it this far, Bravo! Thank you for taking the time. Now don't be\nintimidated by these new syntaxes, this is still JavaScript. The best way to\nimbibe these is by practice. I encourage you to go back to previous sections and\npractice, for further reading check out the resources section. Happy hacking!\n\nYou might also like:\n\n### Resources\n\nThe source of truth when it comes to JavaScript is definitely [Mozilla Developer\nNetwork (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript).\n\n1.  MDN reference on `var`\n1.  MDN reference on `let`\n1.  MDN reference on `const`\n1.  MDN reference on [arrow\n    functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n1.  [Understanding keyword in\n    javascript](https://medium.com/search?q=thiskeyword)\n1.  MDN reference on `export` and default exports\n1.  MDN reference on `import`\n1.  MDN reference on\n    [Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)\n1.  Understanding `new`[ Keyword on\n    MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new)\n1.  Learn more about [inheritance in JavaScript on\n    MDN](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance)\n1.  [MDN reference on Spread\n    Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)\n1.  [MDN rest parameter\n    syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)\n1.  [MDN reference on\n    Destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\n1.  [MDN reference on Primitive\n    types](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)\n1.  [Reference types in\n    Javascript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures)","title":"7 Javascript Concepts to Master Before Any Framework / Library","desc":"JavaScript libraries/frameworks like React or Vue are ruling the web development world. But to truly appreciate their power, you must have a good understanding and command of certain modern JavaScript concepts.\n"}},"pageContext":{"slug":"7-javascript-concepts-to-master-before-any-framework-library"}},"staticQueryHashes":["2337742411"]}